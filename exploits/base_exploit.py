from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, List
from core.target import Vulnerability


class BaseExploit(ABC):
    """Base class for all exploits"""
    
    def __init__(self, name: str):
        self.name = name
    
    @abstractmethod
    def execute(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """
        Execute the exploit on a single vulnerability
        Returns a dict with:
        - success: bool
        - data: Any extracted data
        - evidence: Proof of exploitation
        """
        pass
    
    def execute_cve(self, cve_id: str, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the exploit on all instances of a CVE
        
        Args:
            cve_id: CVE identifier
            finding: Dict from CVEMapper.deduplicate_by_cve() with structure:
            {
                'vuln_type': 'sqli',
                'severity': 'high',
                'url': 'http://example.com',
                'affected_parameters': [
                    {'url': 'http://example.com', 'parameter': 'id', 'payloads': [...]},
                    {'url': 'http://example.com', 'parameter': 'search', 'payloads': [...]}
                ],
                'count': 2,
                'timestamps': [...]
            }
        
        Returns:
            Dict with exploitation results including 'exploited_parameters' list
        """
        # Default implementation: iterate through affected parameters
        # Subclasses can override for optimized CVE-level exploitation
        exploited_params = []
        
        for param_info in finding.get('affected_parameters', []):
            try:
                # Try exploiting this parameter with its payloads
                result = self._exploit_parameter(
                    param_info['url'],
                    param_info['parameter'],
                    param_info['payloads']
                )
                if result:
                    exploited_params.append({
                        'url': param_info['url'],
                        'parameter': param_info['parameter'],
                        'result': result
                    })
            except Exception:
                pass
        
        return {
            'success': len(exploited_params) > 0,
            'cve_id': cve_id,
            'exploited_parameters': exploited_params,
            'data': exploited_params,
            'evidence': f"Exploited {len(exploited_params)} parameter(s)"
        }
    
    def _exploit_parameter(self, url: str, parameter: str, payloads: List[str]) -> Optional[Dict[str, Any]]:
        """
        Attempt to exploit a specific parameter with given payloads
        Override in subclass to implement actual exploitation logic
        """
        return None

