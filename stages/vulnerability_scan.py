from concurrent.futures import ThreadPoolExecutor, as_completed
from core.stage import Stage
from core.target import Target
from scanners.scanner_registry import ScannerRegistry
from utils.cve_mapper import CVEMapper
from observers.console_observer import ConsoleObserver


class VulnerabilityScanStage(Stage):
    """Stage 2: Vulnerability Scanning"""
    
    def __init__(self, config: dict):
        super().__init__("Vulnerability Scanning")
        self.config = config
        self.threads = config.get('threads', 10)
        self.scanner_registry = ScannerRegistry(config=config)
    
    def execute(self, target: Target) -> bool:
        """Scan all discovered subdomains for vulnerabilities"""
        # Ensure we have at least the base domain to scan
        if not target.subdomains:
            target.add_subdomain(target.domain)
        
        # Only clear vulnerabilities if this is part of a full pipeline run
        # In full pipeline: vulnerabilities should be fresh for each run
        # In --stage scan: preserve existing vulnerabilities and deduplicate
        is_full_pipeline_run = target.metadata.get('last_completed_stage', -1) < 2
        
        if is_full_pipeline_run:
            # Fresh scan as part of full pipeline
            target.vulnerabilities = []
        # else: preserve existing vulnerabilities for deduplication in isolated stage runs
        
        self.notify("start", f"Scanning {len(target.subdomains)} subdomains")
        
        try:
            self._scan_subdomains(target)
            
            # Enrich all vulnerabilities with CVE information (global to all scanners)
            CVEMapper.enrich_vulnerabilities(target.vulnerabilities)
            
            # Sort vulnerabilities: CVEs first, then by severity
            target.vulnerabilities.sort(
                key=lambda v: (v.cve_id is None, v.cve_id or "", {"critical": 0, "high": 1, "medium": 2, "low": 3}.get(v.severity, 4))
            )
            
            # Get summary
            summary = target.get_vulnerability_summary()
            cve_summary = CVEMapper.get_cve_summary(target.vulnerabilities)
            
            self.notify("complete", f"Found {summary['total']} vulnerabilities ({cve_summary['identified_cves']} CVEs identified)")
            
            # Display consolidated CVE findings right after scanning
            if target.vulnerabilities:
                cve_map = CVEMapper.deduplicate_by_cve(target.vulnerabilities)
                # Find ConsoleObserver in attached observers
                for observer in self.observers:
                    if isinstance(observer, ConsoleObserver):
                        observer.print_consolidated_cve_findings(cve_map.copy())
                        break
            
            return True
            
        except Exception as e:
            self.notify("error", str(e))
            return False

    def _scan_subdomains(self, target: Target):
        """Scan subdomains concurrently"""
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            # Submit all tasks
            future_to_subdomain = {
                executor.submit(self._scan_single_target, subdomain): subdomain
                for subdomain in target.subdomains
            }
            
            # Process results as they complete
            for future in as_completed(future_to_subdomain, timeout=60):
                subdomain = future_to_subdomain[future]
                
                try:
                    vulnerabilities = future.result(timeout=10)
                    
                    for vuln in vulnerabilities:
                        # Use deduplication - add_vulnerability returns True if new, False if duplicate
                        is_new = target.add_vulnerability(vuln)
                        if is_new:
                            self.notify("vulnerability_found", {
                                'subdomain': subdomain,
                                'type': vuln.vuln_type,
                                'severity': vuln.severity,
                                'cve_id': vuln.cve_id  # Will be enriched later
                            })
                        
                except Exception as e:
                    self.notify("scan_error", f"Failed to scan {subdomain}: {type(e).__name__}")
    
    def _scan_single_target(self, subdomain: str):
        """Run all registered scanners against a target"""
        vulnerabilities = []
        
        for scanner in self.scanner_registry.get_all_scanners():
            try:
                vulns = scanner.scan(subdomain)
                if vulns:
                    vulnerabilities.extend(vulns)
            except Exception as e:
                self.notify("error", f"Scanner {scanner.name} failed: {e}")
        
        return vulnerabilities