from concurrent.futures import ThreadPoolExecutor, as_completed
from core.stage import Stage
from core.target import Target
from scanners.scanner_registry import ScannerRegistry


class VulnerabilityScanStage(Stage):
    """Stage 2: Vulnerability Scanning"""
    
    def __init__(self, config: dict):
        super().__init__("Vulnerability Scanning")
        self.config = config
        self.threads = config.get('threads', 10)
        self.scanner_registry = ScannerRegistry(config=config)
    
    def execute(self, target: Target) -> bool:
        """Scan all discovered subdomains for vulnerabilities"""
        self.notify("start", f"Scanning {len(target.subdomains)} subdomains")
        
        if not target.subdomains:
            self.notify("warning", "No subdomains to scan")
            return True
        
        try:
            self._scan_subdomains(target)
            self.notify("complete", f"Found {len(target.vulnerabilities)} vulnerabilities")
            return True
            
        except Exception as e:
            self.notify("error", str(e))
            return False

    def _scan_subdomains(self, target: Target):
        """Scan subdomains concurrently"""
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            # Submit all tasks
            future_to_subdomain = {
                executor.submit(self._scan_single_target, subdomain): subdomain
                for subdomain in target.subdomains
            }
            
            # Process results as they complete
            for future in as_completed(future_to_subdomain, timeout=60):
                subdomain = future_to_subdomain[future]
                
                try:
                    vulnerabilities = future.result(timeout=10)
                    
                    for vuln in vulnerabilities:
                        target.add_vulnerability(vuln)
                        self.notify("vulnerability_found", {
                            'subdomain': subdomain,
                            'type': vuln.vuln_type,
                            'severity': vuln.severity
                        })
                        
                except Exception as e:
                    self.notify("scan_error", f"Failed to scan {subdomain}: {type(e).__name__}")
    
    def _scan_single_target(self, subdomain: str):
        """Run all registered scanners against a target"""
        vulnerabilities = []
        
        for scanner in self.scanner_registry.get_all_scanners():
            try:
                vulns = scanner.scan(subdomain)
                if vulns:
                    vulnerabilities.extend(vulns)
            except Exception as e:
                self.notify("error", f"Scanner {scanner.name} failed: {e}")
        
        return vulnerabilities